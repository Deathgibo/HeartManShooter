/*Practice FBO*/

	Rectangle rect1;
	rect1.GenerateRectangle(10, 10, 10);

	unsigned int framebuffer;
	glGenFramebuffers(1, &framebuffer);
	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

	unsigned int texColorBuffer;
	glGenTextures(1, &texColorBuffer);
	glBindTexture(GL_TEXTURE_2D, texColorBuffer);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1024, 1024, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glBindTexture(GL_TEXTURE_2D, 0);

	const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;

	unsigned int depthMap;
	glGenTextures(1, &depthMap);
	glBindTexture(GL_TEXTURE_2D, depthMap);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT,
		SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, 0);
	// attach it to currently bound framebuffer object
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0);
	//glDrawBuffer(GL_NONE);
	//glReadBuffer(GL_NONE);

	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
		std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	/*					MAIN LOOP					*/
	while (!glfwWindowShouldClose(window))
	{
		auto fps_start = high_resolution_clock::now();
			
		auto current = high_resolution_clock::now();
		auto elasped = duration_cast<milliseconds>(current - previous);
		previous = current;
		lag += elasped.count();
		Input();	

		while (lag >= MS_PER_UPDATE)
		{
			Update();
			lag -= MS_PER_UPDATE;
			for (int i = 0; i < 1024; i++)
			{
				singlekeys[i].key = false;
			}
		}
		
		/*Practice FBO*/
		glViewport(0, 0, 1024, 1024);
		glBindFramebuffer(GL_FRAMEBUFFER, shadow_diffuse1.fbo);
		glUseProgram(shadershadow.program);
		//vMat = currentcamera->CreateLookAtFunction();
		//mMat = glm::mat4(1.0f);
		//mvMat = pMat * vMat;
		glUniformMatrix4fv(shadershadow.lightmatrix, 1, GL_FALSE, glm::value_ptr(shadow_diffuse1.lightmatrix));
		Render(shadershadow, true);
		/*glEnable(GL_DEPTH_TEST);
		glClear(GL_DEPTH_BUFFER_BIT);
		glClear(GL_COLOR_BUFFER_BIT);
		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		glUniform1i(shadermain.textsample, 1);
		vMat = currentcamera->CreateLookAtFunction();
		mMat = glm::mat4(1.0f);
		mvMat = vMat * mMat;
		glUniformMatrix4fv(shadermain.mLoc, 1, GL_FALSE, glm::value_ptr(mMat));
		glUniformMatrix4fv(shadermain.mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
		glUniformMatrix4fv(shadermain.projLoc, 1, GL_FALSE, glm::value_ptr(pMat));
		firetexture.UseTexture();
		rect1.RenderMesh();*/

		glBindFramebuffer(GL_FRAMEBUFFER, 0); // back to default
		glViewport(0, 0, width, height);
		glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		glClear(GL_DEPTH_BUFFER_BIT);
		glUseProgram(shader2d.program);
		//Render(shadermain, false);

	
		
		/*vMat = glm::mat4(1.0f);
		mMat = glm::mat4(1.0f);
		mvMat = mMat;
		//vMat = currentcamera->CreateLookAtFunction();
		//mMat = glm::mat4(1.0f);
		//mvMat = vMat * mMat;
		glUniformMatrix4fv(shader2d.mLoc, 1, GL_FALSE, glm::value_ptr(mMat));
		glUniformMatrix4fv(shader2d.mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
		glUniformMatrix4fv(shader2d.projLoc, 1, GL_FALSE, glm::value_ptr(mvMat));
		glUniform1i(shader2d.renderdepthmap, 0);
		//glUniform1i(shader2d.depthmap, 3);
		glActiveTexture(GL_TEXTURE1);
		glBindTexture(GL_TEXTURE_2D, texColorBuffer);
		//glBindTexture(GL_TEXTURE_2D, fogtexture.textureid);
		depthmaprect.RenderMesh();

		mMat = glm::mat4(1.0f);
		mMat = glm::translate(mMat, glm::vec3(.5f, 0, 0));
		glUniformMatrix4fv(shader2d.mvLoc, 1, GL_FALSE, glm::value_ptr(mMat));
		glUniform1i(shader2d.renderdepthmap, 1);
		glActiveTexture(GL_TEXTURE3);
		glBindTexture(GL_TEXTURE_2D, depthMap);
		//glBindTexture(GL_TEXTURE_2D, fogtexture.textureid);
		depthmaprect.RenderMesh();*/

		/*Shadow Pass*/
		shadow_diffuse1.CreateLightMatrix(diffuse1);
		glBindFramebuffer(GL_FRAMEBUFFER, shadow_diffuse1.fbo);
		//glClear(GL_DEPTH_BUFFER_BIT);
		//glClear(GL_COLOR_BUFFER_BIT);
		//glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		//glEnable(GL_DEPTH_TEST);
		//glDepthMask(GL_TRUE);
		//glDepthFunc(GL_LEQUAL);
		glUniformMatrix4fv(shadershadow.lightmatrix, 1, GL_FALSE, glm::value_ptr(shadow_diffuse1.lightmatrix));
		glViewport(0, 0, 1024, 1024);
		//glViewport(0, 0, 800, 600);
		//glEnable(GL_DEPTH_TEST);
		//GLenum DrawBuffers[1] = { GL_COLOR_ATTACHMENT0 };
		//glDrawBuffers(1, DrawBuffers); // "1" is the size of DrawBuffers
		Render(shadershadow,true);

		if (singlekeys[GLFW_KEY_P].key)
		{
			GLfloat data[100];
			glReadPixels(600, 600, 10, 10, GL_DEPTH_COMPONENT, GL_FLOAT, &data);
			for (int i = 0; i < 100; i++)
			{
				cout << data[i] << ", ";
			}
		}




		glBindFramebuffer(GL_FRAMEBUFFER, 0);
		glViewport(0, 0, width, height);
		glUseProgram(shader2d.program);
		glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		glClear(GL_DEPTH_BUFFER_BIT);
		Render(shadermain, false);
		
		//cout<< glGetError();

		
		
		/*glBindFramebuffer(GL_FRAMEBUFFER, 0);
		glClear(GL_DEPTH_BUFFER_BIT);
		glClear(GL_COLOR_BUFFER_BIT);
		glClearColor(1.0f, 1.f, 1.0f, 1.0f);*/
		/*Normal Pass*/
		/*glDepthFunc(GL_LEQUAL);
		glViewport(0, 0, width, height);
		glUniform1i(shadermain.depthmap, 3);
		glActiveTexture(GL_TEXTURE3);
		glBindTexture(GL_TEXTURE_2D, shadow_diffuse1.colormap);
		glUniformMatrix4fv(shadermain.lightmatrix, 1, GL_FALSE, glm::value_ptr(shadow_diffuse1.lightmatrix));*/

		//Render(shadermain, false);
		
		GLfloat data2[100];
		glReadPixels(0, 0, 10, 10, GL_DEPTH_COMPONENT, GL_FLOAT, &data2);
		for (int i = 0; i < 100; i++)
		{
			//cout << data2[i] << " ";
		}
		

		/* ADD 60 CAP OPTION*/
